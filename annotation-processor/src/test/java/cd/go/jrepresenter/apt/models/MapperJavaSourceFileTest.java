/*
 * Copyright 2017 ThoughtWorks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cd.go.jrepresenter.apt.models;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.TypeName;
import org.junit.Test;

import static cd.go.jrepresenter.apt.models.TestConstants.EMPTY_LINKS_PROVIDER;
import static cd.go.jrepresenter.apt.models.TestConstants.USER_MODEL;
import static cd.go.jrepresenter.apt.models.TestConstants.USER_REPRESENTER_CLASS;
import static org.assertj.core.api.Assertions.assertThat;

public class MapperJavaSourceFileTest {

    @Test
    public void shouldSerializeSimpleObjectProperties() throws Exception {
        RepresenterAnnotation representerAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withSkipDeserialize(true)
                .withSkipSerialize(false)
                .build();

        Attribute modelAttribute = new Attribute("fname", TypeName.get(String.class));
        Attribute jsonAttribute = new Attribute("firstName", TypeName.get(String.class));
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(representerAnnotation);
        context.addAnnotatedMethod(TestConstants.USER_REPRESENTER_CLASS, propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(representerAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.tw;\n" +
                "\n" +
                "import cd.go.jrepresenter.RequestContext;\n" +
                "import com.tw.User;\n" +
                "import java.lang.Object;\n" +
                "import java.lang.String;\n" +
                "import java.util.LinkedHashMap;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link User}.\n" +
                " * Generated using representer {@link com.tw.UserRepresenter}.\n" +
                " */\n" +
                "public class UserMapper {\n" +
                "  public static Map<String, Object> toJSON(User value, RequestContext requestContext) {\n" +
                "    if (value == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    Map<String, Object> jsonObject = new LinkedHashMap<String, Object>();\n" +
                "    jsonObject.put(\"first_name\", value.getFname());\n" +
                "    return jsonObject;\n" +
                "  }\n" +
                "\n" +
                "  public static List toJSON(List<User> values, RequestContext requestContext) {\n" +
                "    if (values == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    return values.stream().map(eachItem -> UserMapper.toJSON(eachItem, requestContext)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }

    @Test
    public void shouldSerializeSimpleObjectPropertiesAsEmbedded() throws Exception {
        RepresenterAnnotation representerAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withSkipDeserialize(true)
                .withSkipSerialize(false)
                .build();

        Attribute modelAttribute = new Attribute("fname", TypeName.get(String.class));
        Attribute jsonAttribute = new Attribute("firstName", TypeName.get(String.class));
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .withEmbedded(true)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(representerAnnotation);
        context.addAnnotatedMethod(TestConstants.USER_REPRESENTER_CLASS, propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(representerAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.tw;\n" +
                "\n" +
                "import cd.go.jrepresenter.RequestContext;\n" +
                "import com.tw.User;\n" +
                "import java.lang.Object;\n" +
                "import java.lang.String;\n" +
                "import java.util.LinkedHashMap;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link User}.\n" +
                " * Generated using representer {@link com.tw.UserRepresenter}.\n" +
                " */\n" +
                "public class UserMapper {\n" +
                "  public static Map<String, Object> toJSON(User value, RequestContext requestContext) {\n" +
                "    if (value == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    Map<String, Object> jsonObject = new LinkedHashMap<String, Object>();\n" +
                "    Map<String, Object> embeddedMap = new LinkedHashMap<String, Object>();\n" +
                "    embeddedMap.put(\"first_name\", value.getFname());\n" +
                "    jsonObject.put(\"_embedded\", embeddedMap);\n" +
                "    return jsonObject;\n" +
                "  }\n" +
                "\n" +
                "  public static List toJSON(List<User> values, RequestContext requestContext) {\n" +
                "    if (values == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    return values.stream().map(eachItem -> UserMapper.toJSON(eachItem, requestContext)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }

    @Test
    public void shouldSerializeComplexObjectPropertiesAsEmbedded() throws Exception {

        RepresenterAnnotation backupRepresenterAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(ClassName.bestGuess("com.foo.representers.BackupRepresenter"))
                .withModelClass(ClassName.bestGuess("com.foo.Backup"))
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withSkipDeserialize(true)
                .withSkipSerialize(false)
                .build();

        RepresenterAnnotation userRepresenterAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withSkipDeserialize(false)
                .withSkipSerialize(false)
                .build();


        Attribute modelAttribute = new Attribute("backedUpBy", USER_MODEL);
        Attribute jsonAttribute = new Attribute("user", null);
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .withRepresenterClassName(userRepresenterAnnotation.getRepresenterClass())
                .withEmbedded(true)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(backupRepresenterAnnotation);
        context.add(userRepresenterAnnotation);
        context.addAnnotatedMethod(backupRepresenterAnnotation.getRepresenterClass(), propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(backupRepresenterAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.foo.representers;\n" +
                "\n" +
                "import cd.go.jrepresenter.RequestContext;\n" +
                "import com.foo.Backup;\n" +
                "import gen.com.tw.UserMapper;\n" +
                "import java.lang.Object;\n" +
                "import java.lang.String;\n" +
                "import java.util.LinkedHashMap;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link Backup}.\n" +
                " * Generated using representer {@link com.foo.representers.BackupRepresenter}.\n" +
                " */\n" +
                "public class BackupMapper {\n" +
                "  public static Map<String, Object> toJSON(Backup value, RequestContext requestContext) {\n" +
                "    if (value == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    Map<String, Object> jsonObject = new LinkedHashMap<String, Object>();\n" +
                "    Map<String, Object> embeddedMap = new LinkedHashMap<String, Object>();\n" +
                "    embeddedMap.put(\"user\", UserMapper.toJSON(value.getBackedUpBy(), requestContext));\n" +
                "    jsonObject.put(\"_embedded\", embeddedMap);\n" +
                "    return jsonObject;\n" +
                "  }\n" +
                "\n" +
                "  public static List toJSON(List<Backup> values, RequestContext requestContext) {\n" +
                "    if (values == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    return values.stream().map(eachItem -> BackupMapper.toJSON(eachItem, requestContext)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }

    @Test
    public void shouldSkipSerializeIfSpecified() {

        RepresenterAnnotation representerAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withSkipDeserialize(false)
                .withSkipSerialize(true)
                .build();

        Attribute modelAttribute = new Attribute("fname", TypeName.get(String.class));
        Attribute jsonAttribute = new Attribute("firstName", TypeName.get(String.class));
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(representerAnnotation);
        context.addAnnotatedMethod(TestConstants.USER_REPRESENTER_CLASS, propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(representerAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.tw;\n" +
                "\n" +
                "import cd.go.jrepresenter.JsonParseException;\n" +
                "import com.tw.User;\n" +
                "import java.lang.Object;\n" +
                "import java.lang.String;\n" +
                "import java.util.Collections;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link User}.\n" +
                " * Generated using representer {@link com.tw.UserRepresenter}.\n" +
                " */\n" +
                "public class UserMapper {\n" +
                "  public static User fromJSON(Map jsonObject) {\n" +
                "    User model = new User();\n" +
                "    if (jsonObject == null) {\n" +
                "      return model;\n" +
                "    }\n" +
                "    if (jsonObject.containsKey(\"first_name\")) {\n" +
                "      Object jsonAttribute = jsonObject.get(\"first_name\");\n" +
                "      if (!(jsonAttribute instanceof String)) {\n" +
                "        JsonParseException.throwBadJsonType(\"first_name\", String.class, jsonObject);\n" +
                "      }\n" +
                "      String deserializedJsonAttribute = (String) jsonAttribute;\n" +
                "      String modelAttribute = (String) deserializedJsonAttribute;\n" +
                "      model.setFname(modelAttribute);\n" +
                "    }\n" +
                "    return model;\n" +
                "  }\n" +
                "\n" +
                "  public static List<User> fromJSON(List<Map> jsonArray) {\n" +
                "    if (jsonArray == null) {\n" +
                "      return Collections.emptyList();\n" +
                "    }\n" +
                "    return jsonArray.stream().map(eachItem -> UserMapper.fromJSON(eachItem)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }

    @Test
    public void shouldGenerateALinksProviderConstantFieldAlongWithSerializationCode() {

        RepresenterAnnotation representerAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(ClassName.bestGuess("com.example.UserLinksProvider"))
                .withSkipDeserialize(true)
                .withSkipSerialize(false)
                .build();

        Attribute modelAttribute = new Attribute("fname", TypeName.get(String.class));
        Attribute jsonAttribute = new Attribute("firstName", TypeName.get(String.class));
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .withEmbedded(true)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(representerAnnotation);
        context.addAnnotatedMethod(USER_REPRESENTER_CLASS, propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(representerAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.tw;\n" +
                "\n" +
                "import cd.go.jrepresenter.LinksMapper;\n" +
                "import cd.go.jrepresenter.LinksProvider;\n" +
                "import cd.go.jrepresenter.RequestContext;\n" +
                "import com.example.UserLinksProvider;\n" +
                "import com.tw.User;\n" +
                "import java.lang.Object;\n" +
                "import java.lang.String;\n" +
                "import java.util.LinkedHashMap;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link User}.\n" +
                " * Generated using representer {@link com.tw.UserRepresenter}.\n" +
                " */\n" +
                "public class UserMapper {\n" +
                "  private static LinksProvider<User> LINKS_PROVIDER = new UserLinksProvider();\n" +
                "\n" +
                "  public static Map<String, Object> toJSON(User value, RequestContext requestContext) {\n" +
                "    if (value == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    Map<String, Object> jsonObject = new LinkedHashMap<String, Object>();\n" +
                "    jsonObject.putAll(LinksMapper.toJSON(LINKS_PROVIDER, value, requestContext));\n" +
                "    Map<String, Object> embeddedMap = new LinkedHashMap<String, Object>();\n" +
                "    embeddedMap.put(\"first_name\", value.getFname());\n" +
                "    jsonObject.put(\"_embedded\", embeddedMap);\n" +
                "    return jsonObject;\n" +
                "  }\n" +
                "\n" +
                "  public static List toJSON(List<User> values, RequestContext requestContext) {\n" +
                "    if (values == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    return values.stream().map(eachItem -> UserMapper.toJSON(eachItem, requestContext)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }

    @Test
    public void shouldSkipDeserializeIfSpecified() {

        RepresenterAnnotation representerAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withSkipDeserialize(true)
                .withSkipSerialize(false)
                .build();

        Attribute modelAttribute = new Attribute("fname", TypeName.get(String.class));
        Attribute jsonAttribute = new Attribute("firstName", TypeName.get(String.class));
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(representerAnnotation);
        context.addAnnotatedMethod(TestConstants.USER_REPRESENTER_CLASS, propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(representerAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.tw;\n" +
                "\n" +
                "import cd.go.jrepresenter.RequestContext;\n" +
                "import com.tw.User;\n" +
                "import java.lang.Object;\n" +
                "import java.lang.String;\n" +
                "import java.util.LinkedHashMap;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link User}.\n" +
                " * Generated using representer {@link com.tw.UserRepresenter}.\n" +
                " */\n" +
                "public class UserMapper {\n" +
                "  public static Map<String, Object> toJSON(User value, RequestContext requestContext) {\n" +
                "    if (value == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    Map<String, Object> jsonObject = new LinkedHashMap<String, Object>();\n" +
                "    jsonObject.put(\"first_name\", value.getFname());\n" +
                "    return jsonObject;\n" +
                "  }\n" +
                "\n" +
                "  public static List toJSON(List<User> values, RequestContext requestContext) {\n" +
                "    if (values == null) {\n" +
                "      return null;\n" +
                "    }\n" +
                "    return values.stream().map(eachItem -> UserMapper.toJSON(eachItem, requestContext)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }

    @Test
    public void shouldGenerateCustomDeserializerIfDeserializerClassIsSpecified() {
        RepresenterAnnotation representerAnnotation = RepresenterAnnotationBuilder.aRepresenterAnnotation()
                .withRepresenterClass(TestConstants.USER_REPRESENTER_CLASS)
                .withModelClass(USER_MODEL)
                .withLinksProviderClass(EMPTY_LINKS_PROVIDER)
                .withDeserializerClass(ClassName.bestGuess("com.tw.CustomMapper"))
                .withSkipSerialize(true)
                .build();

        Attribute modelAttribute = new Attribute("fname", TypeName.get(String.class));
        Attribute jsonAttribute = new Attribute("firstName", TypeName.get(String.class));
        PropertyAnnotation propertyAnnotation = PropertyAnnotationBuilder.aPropertyAnnotation()
                .withModelAttribute(modelAttribute)
                .withJsonAttribute(jsonAttribute)
                .build();
        ClassToAnnotationMap context = new ClassToAnnotationMap();
        context.add(representerAnnotation);
        context.addAnnotatedMethod(TestConstants.USER_REPRESENTER_CLASS, propertyAnnotation);
        MapperJavaSourceFile mapperJavaSourceFile = new MapperJavaSourceFile(representerAnnotation, context);

        assertThat(mapperJavaSourceFile.toSource()).isEqualTo("" +
                "//\n" +
                "// This file was automatically generated by jrepresenter\n" +
                "// Any changes may be lost!\n" +
                "//\n" +
                "package gen.com.tw;\n" +
                "\n" +
                "import com.tw.User;\n" +
                "import gen.cd.go.jrepresenter.Constants;\n" +
                "import java.util.Collections;\n" +
                "import java.util.List;\n" +
                "import java.util.Map;\n" +
                "import java.util.stream.Collectors;\n" +
                "\n" +
                "/**\n" +
                " * Representer for {@link User}.\n" +
                " * Generated using representer {@link com.tw.UserRepresenter}.\n" +
                " */\n" +
                "public class UserMapper {\n" +
                "  public static User fromJSON(Map jsonObject) {\n" +
                "    return Constants.ToJSONMappers.CUSTOM.apply(jsonObject);\n" +
                "  }\n" +
                "\n" +
                "  public static List<User> fromJSON(List<Map> jsonArray) {\n" +
                "    if (jsonArray == null) {\n" +
                "      return Collections.emptyList();\n" +
                "    }\n" +
                "    return jsonArray.stream().map(eachItem -> UserMapper.fromJSON(eachItem)).collect(Collectors.toList());\n" +
                "  }\n" +
                "}\n");
    }
}
